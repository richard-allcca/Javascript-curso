‚óÄ ‚óÜ ‚ñ∂
Cap√≠tulo 9
Expresiones regulares
Algunas personas, cuando se enfrentan a un problema, piensan:'Lo s√©, usar√© expresiones regulares'. Ahora tienen dos problemas.

Jamie Zawinski
Yuan-Ma dijo: 'Cuando cortas contra el grano de la madera, se necesita mucha fuerza. Cuando se programa contra el grano del problema, se necesita mucho c√≥digo.'

Maestro Yuan-Ma, El libro de programaci√≥n
A railroad diagram
Las herramientas y t√©cnicas de programaci√≥n sobreviven y se propagan de una manera ca√≥tica y evolutiva. No siempre son los bonitos o brillantes los que ganan, sino los que funcionan lo suficientemente bien dentro del nicho correcto o que pasan a estar integrados con otra pieza de tecnolog√≠a exitosa.

En este cap√≠tulo, discutir√© una de esas herramientas, expresiones regulares. Las expresiones regulares son una forma de describir patrones en los datos de cadena. Forman un lenguaje peque√±o e independiente que forma parte de JavaScript y muchos otros lenguajes y sistemas.

Las expresiones regulares son terriblemente inc√≥modas y extremadamente √∫tiles. Su sintaxis es cr√≠ptica, y la interfaz de programaci√≥n que JavaScript proporciona para ellos es torpe. Pero son una poderosa herramienta para inspeccionar y procesar cadenas. Comprender correctamente las expresiones regulares le har√° un programador m√°s eficaz.

Creaci√≥n de una expresi√≥n regular
Una expresi√≥n regular es un tipo de objeto. Se puede construir con el constructor o escribirse como un valor literal encerrando un patr√≥n en caracteres de barra diagonal ().RegExp/

editar y ejecutar c√≥digo haciendo clic en √©llet re1 = new RegExp("abc");
let re2 = /abc/;
Ambos objetos de expresi√≥n regular representan el mismo patr√≥n: un car√°cter seguido de un b seguido de un c.

Cuando se utiliza el constructor, el patr√≥n se escribe como una cadena normal, por lo que las reglas habituales se aplican a las barras diagonales inversas.RegExp

La segunda notaci√≥n, donde el patr√≥n aparece entre caracteres de barra diagonal, trata las barras diagonales inversas de forma diferente. En primer lugar, ya que una barra diagonal termina el patr√≥n, necesitamos poner una barra diagonal inversa antes de cualquier barra diagonal que queremos ser parte del patr√≥n. Adem√°s, se conservar√°nlas barras diagonales inversas que no forman parte de c√≥digos de caracteres especiales (como ) , en lugar de ignorarse como est√°n en cadenas, y cambiar√°n el significado del patr√≥n. Algunos caracteres, como los signos de interrogaci√≥n y signos m√°s, tienen significados especiales en las expresiones regulares y deben ir precedidos de una barra diagonal invertida si est√°n destinados a representar el car√°cter en s√≠.\n

let eighteenPlus = /eighteen\+/;
Pruebas para los partidos
Los objetos de expresi√≥n regular tienen una serie de m√©todos. El m√°s simple es . Si le pasa una cadena, devolver√° un valor booleano que le indicar√° si la cadena contiene una coincidencia del patr√≥n en la expresi√≥n.test

console.log(/abc/.test("abcde"));
// ‚Üí true
console.log(/abc/.test("abxde"));
// ‚Üí false
Una expresi√≥n regular que consta √∫nicamente de caracteres no especiales representa simplemente esa secuencia de caracteres. Si abc se produce en cualquier parte de la cadena con la que estamos probando (no solo al principio), devolver√° .testtrue

Conjuntos de caracteres
Averiguar si una cadena contiene abc tambi√©n podr√≠a hacerse con una llamada a . Las expresiones regulares nos permiten expresar patrones m√°s complicados.indexOf

Digamos que queremos coincidir con cualquier n√∫mero. En una expresi√≥n regular, colocar un conjunto de caracteres entre corchetes hace que esa parte de la expresi√≥n coincida con cualquiera de los caracteres entre corchetes.

Las dos expresiones siguientes coinciden con todas las cadenas que contienen un d√≠gito:

console.log(/[0123456789]/.test("in 1992"));
// ‚Üí true
console.log(/[0-9]/.test("in 1992"));
// ‚Üí true
Entre corchetes, se puede utilizar un gui√≥n () entre dos caracteres para indicar un intervalo de caracteres, donde el orden viene determinado por el n√∫mero Unicode del car√°cter. Los caracteres 0 a 9 se sientan uno al lado del otro en este orden (c√≥digos 48 a 57), por lo que cubre todos ellos y coincide con cualquier d√≠gito.-[0-9]

Varios grupos de caracteres comunes tienen sus propios accesos directos integrados. Los d√≠gitos son uno de ellos: significa lo mismo que .\d[0-9]

\d	Cualquier car√°cter de d√≠gito
\w	Un car√°cter alfanum√©rico ("car√°cter de palabra")
\s	Cualquier car√°cter de espacio en blanco (espacio, tabulaci√≥n, nueva l√≠nea y similares)
\D	Un car√°cter que no es un d√≠gito
\W	Un car√°cter no alfanum√©rico
\S	Car√°cter no espacial
.	Cualquier personaje excepto newline
Por lo que podr√≠a coincidir con un formato de fecha y hora como 01-30-2003 15:20 con la siguiente expresi√≥n:

let dateTime = /\d\d-\d\d-\d\d\d\d \d\d:\d\d/;
console.log(dateTime.test("01-30-2003 15:20"));
// ‚Üí true
console.log(dateTime.test("30-jan-2003 15:20"));
// ‚Üí false
Eso se ve completamente horrible, ¬øno? La mitad son barras diagonales inversas, produciendo un ruido de fondo que hace dif√≠cil detectar el patr√≥n real expresado. Veremos una versi√≥n ligeramente mejorada de esta expresi√≥n m√°s adelante.

Estos c√≥digos de barra diagonal invertida tambi√©n se pueden utilizar entre corchetes. Por ejemplo, significa cualquier d√≠gito o un car√°cter de punto. Pero el per√≠odo en s√≠, entre corchetes, pierde su significado especial. Lo mismo ocurre con otros caracteres especiales, como .[\d.]+

Para invertir un conjunto de caracteres, es decir, para expresar que desea que coincida con cualquier car√°cter excepto los del conjunto, puede escribir un car√°cter de intercalaci√≥n () despu√©s del corchete de apertura.^

let notBinary = /[^01]/;
console.log(notBinary.test("1100100010100110"));
// ‚Üí false
console.log(notBinary.test("1100100010200110"));
// ‚Üí true
Repetir partes de un patr√≥n
Ahora sabemos c√≥mo hacer coincidir un solo d√≠gito. ¬øQu√© pasa si queremos hacer coincidir un n√∫mero entero, una secuencia de uno o m√°s d√≠gitos?

Cuando se coloca un signo m√°s () despu√©s de algo en una expresi√≥n regular, indica que el elemento se puede repetir m√°s de una vez. Por lo tanto, coincide con uno o m√°s caracteres de d√≠gitos.+/\d+/

console.log(/'\d+'/.test("'123'"));
// ‚Üí true
console.log(/'\d+'/.test("''"));
// ‚Üí false
console.log(/'\d*'/.test("'123'"));
// ‚Üí true
console.log(/'\d*'/.test("''"));
// ‚Üí true
La estrella () tiene un significado similar, pero tambi√©n permite que el patr√≥n coincida con cero veces. Algo con una estrella despu√©s de que nunca impide que un patr√≥n coincida, solo coincidir√° con cero instancias si no puede encontrar ning√∫n texto adecuado para que coincida.*

Un signo de interrogaci√≥n hace que una parte de un patr√≥n sea opcional,lo que significa que puede producirse cero veces o una vez. En el ejemplo siguiente, se permite que se produzca el car√°cter u, pero el patr√≥n tambi√©n coincide cuando falta.

let neighbor = /neighbou?r/;
console.log(neighbor.test("neighbour"));
// ‚Üí true
console.log(neighbor.test("neighbor"));
// ‚Üí true
Para indicar que un patr√≥n debe producirse un n√∫mero preciso de veces, utilice llaves. Poner despu√©s de un elemento, por ejemplo, requiere que se produzca exactamente cuatro veces. Tambi√©n es posible especificar un rango de esta manera: significa que el elemento debe producirse al menos dos veces y como m√°ximo cuatro veces.{4}{2,4}

Here is another version of the date and time pattern that allows both single- and double-digit days, months, and hours. It is also slightly easier to decipher.

let dateTime = /\d{1,2}-\d{1,2}-\d{4} \d{1,2}:\d{2}/;
console.log(dateTime.test("1-30-2003 8:45"));
// ‚Üí true
You can also specify open-ended ranges when using braces by omitting the number after the comma. So, means five or more times.{5,}

Agrupar subexpresiones
Para utilizar un operador similar o en m√°s de un elemento a la vez, debe usar par√©ntesis. Una parte de una expresi√≥n regular que est√° entre par√©ntesis cuenta como un √∫nico elemento en lo que respecta a los operadores siguientes.*+

let cartoonCrying = /boo+(hoo+)+/i;
console.log(cartoonCrying.test("Boohoooohoohooo"));
// ‚Üí true
El primer y segundo car√°cter se aplican s√≥lo a la segunda o in boo y hoo, respectivamente. El tercero se aplica a todo el grupo, que coincide con una o m√°s secuencias como esa.++(hoo+)

El final de la expresi√≥n en el ejemplo hace que esta expresi√≥n regular no distintive, lo que le permite coincidir con la B en may√∫sculas en la cadena de entrada, aunque el patr√≥n est√° en s√≠ en min√∫sculas.i

Partidos y grupos
El m√©todo es la forma m√°s sencilla y absoluta de hacer coincidir una expresi√≥n regular. S√≥lo te dice si coincid√≠a y nada m√°s. Las expresiones regulares tambi√©n tienen un m√©todo (execute) que se devolver√° si no se encontr√≥ ninguna coincidencia y devuelven un objeto con informaci√≥n sobre la coincidencia en caso contrario.testexecnull

let match = /\d+/.exec("one two 100");
console.log(match);
// ‚Üí ["100"]
console.log(match.index);
// ‚Üí 8
Un objeto devuelto por tiene una propiedad que nos indica d√≥nde comienza la coincidencia correcta en la cadena. Aparte de eso, el objeto se ve como (y de hecho es) una matriz de cadenas, cuyo primer elemento es la cadena que se hizo coincidir. En el ejemplo anterior, esta es la secuencia de d√≠gitos que est√°bamos buscando.execindex

Los valores de cadena tienen un m√©todo que se comporta de forma similar.match

console.log("one two 100".match(/\d+/));
// ‚Üí ["100"]
Cuando la expresi√≥n regular contiene subexpresiones agrupadas con par√©ntesis, el texto que coincida con esos grupos tambi√©n se mostrar√° en la matriz. Toda la coincidencia es siempre el primer elemento. El siguiente elemento es la parte que coincide con el primer grupo (el que tiene par√©ntesis de apertura viene primero en la expresi√≥n), luego el segundo grupo, etc.

let quotedText = /'([^']*)'/;
console.log(quotedText.exec("she said 'hello'"));
// ‚Üí ["'hello'", "hello"]
Cuando un grupo no termina siendo emparejado en absoluto (por ejemplo, cuando va seguido de un signo de interrogaci√≥n), su posici√≥n en la matriz de salida se mantendr√° . De forma similar, cuando un grupo coincide varias veces, solo la √∫ltima coincidencia termina en la matriz.undefined

console.log(/bad(ly)?/.exec("bad"));
// ‚Üí ["bad", undefined]
console.log(/(\d)+/.exec("123"));
// ‚Üí ["123", "3"]
Los grupos pueden ser √∫tiles para extraer partes de una cadena. Si no solo queremos verificar si una cadena contiene una fecha, sino tambi√©n extraerla y construir un objeto que la represente, podemos ajustar par√©ntesis alrededor de los patrones de d√≠gitos y elegir directamente la fecha del resultado de .exec

Pero primero tomaremos un breve desv√≠o, en el que analizamos la forma integrada de representar los valores de fecha y hora en JavaScript.

La clase Date
JavaScript tiene una clase est√°ndar para representar fechas o, m√°s bien, puntos en el tiempo. Se llama . Si simplemente crea un objeto de fecha utilizando , obtendr√° la fecha y hora actuales.Datenew

console.log(new Date());
// ‚Üí Mon Nov 13 2017 16:19:11 GMT+0100 (CET)
Tambi√©n puede crear un objeto para un tiempo espec√≠fico.

console.log(new Date(2009, 11, 9));
// ‚Üí Wed Dec 09 2009 00:00:00 GMT+0100 (CET)
console.log(new Date(2009, 11, 9, 12, 59, 59, 999));
// ‚Üí Wed Dec 09 2009 12:59:59 GMT+0100 (CET)
JavaScript uses a convention where month numbers start at zero (so December is 11), yet day numbers start at one. This is confusing and silly. Be careful.

The last four arguments (hours, minutes, seconds, and milliseconds) are optional and taken to be zero when not given.

Timestamps are stored as the number of milliseconds since the start of 1970, in the UTC time zone. This follows a convention set by ‚ÄúUnix time‚Äù, which was invented around that time. You can use negative numbers for times before 1970. The method on a date object returns this number. It is big, as you can imagine.getTime

console.log(new Date(2013, 11, 19).getTime());
// ‚Üí 1387407600000
console.log(new Date(1387407600000));
// ‚Üí Thu Dec 19 2013 00:00:00 GMT+0100 (CET)
If you give the constructor a single argument, that argument is treated as such a millisecond count. You can get the current millisecond count by creating a new object and calling on it or by calling the function.DateDategetTimeDate.now

Date objects provide methods such as , , , , , and to extract their components. Besides there‚Äôs also , which gives you the year minus 1900 ( or ) and is mostly useless.getFullYeargetMonthgetDategetHoursgetMinutesgetSecondsgetFullYeargetYear98119

Putting parentheses around the parts of the expression that we are interested in, we can now create a date object from a string.

function getDate(string) {
  let [_, month, day, year] =
    /(\d{1,2})-(\d{1,2})-(\d{4})/.exec(string);
  return new Date(year, month - 1, day);
}
console.log(getDate("1-30-2003"));
// ‚Üí Thu Jan 30 2003 00:00:00 GMT+0100 (CET)
The (underscore) binding is ignored and used only to skip the full match element in the array returned by ._exec

Word and string boundaries
Unfortunately, will also happily extract the nonsensical date 00-1-3000 from the string . A match may happen anywhere in the string, so in this case, it‚Äôll just start at the second character and end at the second-to-last character.getDate"100-1-30000"

Si queremos exigir que la coincidencia debe abarcar toda la cadena, podemos agregar los marcadores y . El s√≠mbolo de intercalaci√≥n coincide con el inicio de la cadena de entrada, mientras que el signo de d√≥lar coincide con el final. Por lo tanto, coincide con una cadena que consta enteramente de uno o m√°s d√≠gitos, coincide con cualquier cadena que comience con un signo de exclamaci√≥n y no coincida con ninguna cadena (no puede haber una x antes del inicio de la cadena).^$/^\d+$//^!//x^/

Si, por otro lado, s√≥lo queremos asegurarnos de que la fecha comienza y termina en un l√≠mite de palabras, podemos usar el marcador . Un l√≠mite de palabra puede ser el inicio o el final de la cadena o cualquier punto de la cadena que tenga un car√°cter de palabra (como en ) en un lado y un car√°cter sin palabra en el otro.\b\w

console.log(/cat/.test("concatenate"));
// ‚Üí true
console.log(/\bcat\b/.test("concatenate"));
// ‚Üí false
Tenga en cuenta que un marcador de l√≠mite no coincide con un car√°cter real. S√≥lo aplica que la expresi√≥n regular coincide solo cuando una determinada condici√≥n se mantiene en el lugar donde aparece en el patr√≥n.

Patrones de elecci√≥n
Digamos que queremos saber si un pedazo de texto contiene no s√≥lo un n√∫mero, sino un n√∫mero seguido de una de las palabras cerdo, vaca,o pollo,o cualquiera de sus formas plurales.

Podr√≠amos escribir tres expresiones regulares y probarlas a su vez, pero hay una manera m√°s agradable. El car√°cter de tuber√≠a () indica una elecci√≥n entre el patr√≥n a su izquierda y el patr√≥n a su derecha. As√≠ que puedo decir esto:|

let animalCount = /\b\d+ (pig|cow|chicken)s?\b/;
console.log(animalCount.test("15 pigs"));
// ‚Üí true
console.log(animalCount.test("15 pigchickens"));
// ‚Üí false
Los par√©ntesis se pueden utilizar para limitar la parte del patr√≥n al que se aplica el operador de tuber√≠a, y puede colocar varios de estos operadores uno al lado del otro para expresar una opci√≥n entre m√°s de dos alternativas.

La mec√°nica de la coincidencia
Conceptualmente, cuando se usa o , el motor de expresiones regulares busca una coincidencia en la cadena intentando hacer coincidir la expresi√≥n primero desde el inicio de la cadena, a continuaci√≥n, desde el segundo car√°cter, etc., hasta que encuentre una coincidencia o llegue al final de la cadena. Devolver√° la primera coincidencia que se puede encontrar o no encontrar√° ninguna coincidencia.exectest

Para realizar la coincidencia real, el motor trata una expresi√≥n regular algo as√≠ como un diagrama de flujo. Este es el diagrama para la expresi√≥n ganadera en el ejemplo anterior:

Visualization of /\b\d+ (pig|cow|chicken)s?\b/
Nuestra expresi√≥n coincide si podemos encontrar una ruta desde el lado izquierdo del diagrama hasta el lado derecho. Mantenemos una posici√≥n actual en la cadena, y cada vez que nos movemos a trav√©s de un cuadro, verificamos que la parte de la cadena despu√©s de nuestra posici√≥n actual coincide con ese cuadro.

As√≠ que si tratamos de igualar desde la posici√≥n 4, nuestro progreso a trav√©s del diagrama de flujo se ver√≠a as√≠:"the 3 pigs"

En la posici√≥n 4, hay un l√≠mite de palabras, por lo que podemos movernos m√°s all√° de la primera caja.

Todav√≠a en la posici√≥n 4, encontramos un d√≠gito, as√≠ que tambi√©n podemos movernos m√°s all√° de la segunda caja.

En la posici√≥n 5, un trazado vuelve a ser antes del segundo cuadro (d√≠gito), mientras que el otro se mueve hacia delante a trav√©s del cuadro que contiene un solo car√°cter de espacio. Hay un espacio aqu√≠, no un d√≠gito, as√≠ que debemos tomar el segundo camino.

Ahora estamos en la posici√≥n 6 (el inicio de los cerdos)y en la rama de tres v√≠as en el diagrama. Aqu√≠ no vemos vaca ni pollo, pero s√≠ cerdo,as√≠ que tomamos esa rama.

En la posici√≥n 9, despu√©s de la bifurcaci√≥n de tres v√≠as, una ruta salta el cuadro s y va directamente al l√≠mite de la palabra final, mientras que el otro trazado coincide con un s. Hay un car√°cter s aqu√≠, no un l√≠mite de palabra, as√≠ que pasamos por el cuadro s.

Estamos en la posici√≥n 10 (el final de la cadena) y solo podemos coincidir con un l√≠mite de palabra. El final de una cadena cuenta como un l√≠mite de palabra, por lo que pasamos por el √∫ltimo cuadro y hemos hecho coincidir correctamente con esta cadena.

Retroceso
La expresi√≥n regular coincide con un n√∫mero binario seguido de un b,un n√∫mero hexadecimal (es decir, base 16, con las letras a a f de pie para los d√≠gitos 10 a 15) seguido de un h, o un n√∫mero decimal normal sin car√°cter de sufijo. Este es el diagrama correspondiente:/\b([01]+b|[\da-f]+h|\d+)\b/

Visualization of /\b([01]+b|\d+|[\da-f]+h)\b/
Al hacer coincidir esta expresi√≥n, a menudo suceder√° que se introduce la rama superior (binaria) aunque la entrada no contenga realmente un n√∫mero binario. Al hacer coincidir la cadena, por ejemplo, se hace evidente s√≥lo en el 3 que estamos en la rama incorrecta. La cadena coincide con la expresi√≥n, pero no con la rama en la que estamos actualmente."103"

As√≠ que el emparejador retrocede. Al escribir una rama, recuerda su posici√≥n actual (en este caso, al principio de la cadena, justo despu√©s del primer cuadro de l√≠mite en el diagrama) para que pueda volver atr√°s y probar otra rama si la actual no funciona. Para la cadena, despu√©s de encontrar el car√°cter 3, comenzar√° a probar la rama para n√∫meros hexadecimales, lo que falla de nuevo porque no hay h despu√©s del n√∫mero. As√≠ que intenta la rama de n√∫mero decimal. Este encaja, y se reporta un partido despu√©s de todo."103"

El emparejador se detiene tan pronto como encuentra una coincidencia completa. Esto significa que si varias ramas podr√≠an coincidir potencialmente con una cadena, solo se utiliza la primera (ordenada por donde aparecen las ramas en la expresi√≥n regular).

El retroceso tambi√©n ocurre para operadores de repetici√≥n como + y . Si coincide con , la parte primero intentar√° consumir toda la cadena. El motor entonces se dar√° cuenta de que necesita una x para que coincida con el patr√≥n. Puesto que no hay x m√°s all√° del final de la cadena, el operador de estrella intenta hacer coincidir un car√°cter menos. Pero el emparejador no encuentra una x despu√©s de cualquiera de los dos, por lo que retrocede de nuevo, haciendo coincidir el operador estrella con s√≥lo . Ahora encuentra una x donde la necesita e informa de un partido exitoso de las posiciones 0 a 4.*/^.*x/"abcxe".*abcxabc

Es posible escribir expresiones regulares que har√°n mucho retroceso. Este problema se produce cuando un patr√≥n puede coincidir con un fragmento de entrada de muchas maneras diferentes. Por ejemplo, si nos confundimos al escribir una expresi√≥n regular de n√∫mero binario, podr√≠amos escribir accidentalmente algo como ./([01]+)+b/

Visualization of /([01]+)+b/
Si eso intenta hacer coincidir algunas series largas de ceros y unos sin car√°cter b final, el emparejador primero pasa a trav√©s del bucle interno hasta que se queda sin d√≠gitos. Entonces se da cuenta de que no hay b, por lo que retrocede una posici√≥n, pasa a trav√©s del bucle exterior una vez, y se da por venciendo de nuevo, tratando de retroceder fuera del bucle interno una vez m√°s. Continuar√° probando todas las rutas posibles a trav√©s de estos dos loops. Esto significa que la cantidad de trabajo se duplica con cada car√°cter adicional. Incluso para unas pocas docenas de personajes, el partido resultante tomar√° pr√°cticamente para siempre.

El m√©todo de reemplazo
Los valores de cadena tienen un m√©todo que se puede usar para reemplazar parte de la cadena por otra cadena.replace

console.log("papa".replace("p", "m"));
// ‚Üí mapa
El primer argumento tambi√©n puede ser una expresi√≥n regular, en cuyo caso se reemplaza la primera coincidencia de la expresi√≥n regular. Cuando se agrega una opci√≥n (para global)a la expresi√≥n regular, se reemplazar√°n todas las coincidencias de la cadena, no solo la primera.g

console.log("Borobudur".replace(/[ou]/, "a"));
// ‚Üí Barobudur
console.log("Borobudur".replace(/[ou]/g, "a"));
// ‚Üí Barabadar
Hubiera sido sensato si la elecci√≥n entre la sustituci√≥n de una coincidencia o todas las coincidencias se hizo a trav√©s de un argumento adicional a o proporcionando un m√©todo diferente, . Pero por alguna raz√≥n desafortunada, la elecci√≥n se basa en una propiedad de la expresi√≥n regular en su lugar.replacereplaceAll

El poder real de usar expresiones regulares proviene del hecho de que podemos hacer referencia a grupos coincidentes en la cadena de reemplazo. Por ejemplo, supongamos que tenemos una cadena grande que contiene los nombres de personas, un nombre por l√≠nea, en el formato . Si queremos intercambiar estos nombres y eliminar la coma para obtener un formato, podemos usar el siguiente c√≥digo:replaceLastname, FirstnameFirstname Lastname

console.log(
  "Liskov, Barbara\nMcCarthy, John\nWadler, Philip"
    .replace(/(\w+), (\w+)/g, "$2 $1"));
// ‚Üí Barbara Liskov
//   John McCarthy
//   Philip Wadler
El y en la cadena de reemplazo hace referencia a los grupos entre par√©ntesis en el patr√≥n. se sustituye por el texto que coincide con el primer grupo, por el segundo, y as√≠ sucesivamente, hasta . Todo el partido se puede hacer referencia con .$1$2$1$2$9$&

Es posible pasar una funci√≥n, en lugar de una cadena, como segundo argumento para . Para cada reemplazo, se llamar√° a la funci√≥n con los grupos coincidentes (as√≠ como toda la coincidencia) como argumentos, y su valor devuelto se insertar√° en la nueva cadena.replace

Este es un peque√±o ejemplo:

let s = "the cia and fbi";
console.log(s.replace(/\b(fbi|cia)\b/g,
            str => str.toUpperCase()));
// ‚Üí the CIA and FBI
Aqu√≠ hay uno m√°s interesante:

let stock = "1 lemon, 2 cabbages, and 101 eggs";
function minusOne(match, amount, unit) {
  amount = Number(amount) - 1;
  if (amount == 1) { // only one left, remove the 's'
    unit = unit.slice(0, unit.length - 1);
  } else if (amount == 0) {
    amount = "no";
  }
  return amount + " " + unit;
}
console.log(stock.replace(/(\d+) (\w+)/g, minusOne));
// ‚Üí no lemon, 1 cabbage, and 100 eggs
Esto toma una cadena, busca todas las apariciones de un n√∫mero seguido de una palabra alfanum√©rica y devuelve una cadena en la que cada aparici√≥n de este tipo se reduce en uno.

El grupo termina como argumento para la funci√≥n y el grupo se enlaza a . La funci√≥n se convierte en un n√∫mero, que siempre funciona desde que coincide, y realiza algunos ajustes en caso de que solo quede uno o cero.(\d+)amount(\w+)unitamount\d+

Avaricia
Es posible utilizar para escribir una funci√≥n que elimina todos los comentarios de un fragmento de c√≥digo JavaScript. Aqu√≠ est√° un primer intento:replace

function stripComments(code) {
  return code.replace(/\/\/.*|\/\*[^]*\*\//g, "");
}
console.log(stripComments("1 + /* 2 */3"));
// ‚Üí 1 + 3
console.log(stripComments("x = 10;// ten!"));
// ‚Üí x = 10;
console.log(stripComments("1 /* a */+/* b */ 1"));
// ‚Üí 1  1
La parte antes del operador or coincide con dos caracteres de barra diagonal seguidos de cualquier n√∫mero de caracteres que no sean de nueva l√≠nea. La parte de los comentarios multil√≠nea est√° m√°s implicada. Usamos (cualquier car√°cter que no est√© en el conjunto vac√≠o de caracteres) como una forma de hacer coincidir cualquier car√°cter. No podemos usar simplemente un punto aqu√≠ porque los comentarios de bloque pueden continuar en una nueva l√≠nea y el car√°cter de punto no coincide con los caracteres de nueva l√≠nea.[^]

Pero la salida de la √∫ltima l√≠nea parece haber salido mal. ¬øpor qu√©?

La parte de la expresi√≥n, como describ√≠ en la secci√≥n sobre el retroceso, primero coincidir√° tanto como pueda. Si eso hace que la siguiente parte del patr√≥n falle, el emparejador retrocede un car√°cter e intenta de nuevo desde all√≠. En el ejemplo, el emparejador primero intenta hacer coincidir todo el resto de la cadena y, a continuaci√≥n, se mueve hacia atr√°s desde all√≠. Se encontrar√° una ocurrencia de despu√©s de volver cuatro caracteres y coincidir con eso. Esto no es lo que quer√≠amos, la intenci√≥n era hacer coincidir un solo comentario, no ir hasta el final del c√≥digo y encontrar el final del √∫ltimo comentario de bloque.[^]**/

Debido a este comportamiento, decimos que los operadores de repetici√≥n (, , , y ) son codiciosos,lo que significa que coinciden tanto como pueden y retroceden desde all√≠. Si pone un signo de interrogaci√≥n despu√©s de ellos (, , , ), se convierten en nogre√±idos y comienzan haciendo coincidir lo menos posible, haciendo coincidir m√°s solo cuando el patr√≥n restante no se ajusta a la coincidencia m√°s peque√±a.+*?{}+?*???{}?

Y eso es exactamente lo que queremos en este caso. Al tener la estrella coincide con el tramo m√°s peque√±o de caracteres que nos lleva a un , consumimos un comentario de bloque y nada m√°s.*/

function stripComments(code) {
  return code.replace(/\/\/.*|\/\*[^]*?\*\//g, "");
}
console.log(stripComments("1 /* a */+/* b */ 1"));
// ‚Üí 1 + 1
Una gran cantidad de errores en los programas de expresi√≥n regular se puede rastrear a involuntariamente usando un operador codicioso donde uno nogreedy funcionar√≠a mejor. Cuando utilice un operador de repetici√≥n, tenga en cuenta primero la variante nogreedy.

Creaci√≥n din√°mica de objetos RegExp
Hay casos en los que es posible que no sepa el patr√≥n exacto con el que debe coincidir al escribir el c√≥digo. Supongamos que desea buscar el nombre del usuario en un fragmento de texto y encerrarlo en caracteres de subrayado para que destaque. Puesto que sabr√° el nombre s√≥lo una vez que el programa se est√° ejecutando realmente, no puede usar la notaci√≥n basada en barra diagonal.

Pero puede crear una cadena y usar el constructor en eso. Este es un ejemplo:RegExp

let name = "harry";
let text = "Harry is a suspicious character.";
let regexp = new RegExp("\\b(" + name + ")\\b", "gi");
console.log(text.replace(regexp, "_$1_"));
// ‚Üí _Harry_ is a suspicious character.
Al crear los marcadores de l√≠mite, tenemos que usar dos barras diagonales inversas porque las estamos escribiendo en una cadena normal, no en una expresi√≥n regular cerrada con barra diagonal. El segundo argumento del constructor contiene las opciones para la expresi√≥n regular, en este caso, para global y sin distinci√≥n entre may√∫sculas y min√∫sculas.\bRegExp"gi"

Pero, ¬øy si el nombre es porque nuestro usuario es un adolescente nerd? Eso resultar√≠a en una expresi√≥n regular sin sentido que en realidad no coincidir√° con el nombre del usuario."dea+hl[]rd"

Para evitar esto, podemos agregar barras diagonales inversas antes de cualquier car√°cter que tenga un significado especial.

let name = "dea+hl[]rd";
let text = "This dea+hl[]rd guy is super annoying.";
let escaped = name.replace(/[\\[.+*?(){|^$]/g, "\\$&");
let regexp = new RegExp("\\b" + escaped + "\\b", "gi");
console.log(text.replace(regexp, "_$&_"));
// ‚Üí This _dea+hl[]rd_ guy is super annoying.
El m√©todo de b√∫squeda
No se puede llamar al m√©todo en cadenas con una expresi√≥n regular. Pero hay otro m√©todo, , que espera una expresi√≥n regular. Al igual que , devuelve el primer √≠ndice en el que se encontr√≥ la expresi√≥n, o -1 cuando no se encontr√≥.indexOfsearchindexOf

console.log("  word".search(/\S/));
// ‚Üí 2
console.log("    ".search(/\S/));
// ‚Üí -1
Desafortunadamente, no hay manera de indicar que la coincidencia debe comenzar en un desplazamiento dado (como podemos con el segundo argumento para ), lo que a menudo ser√≠a √∫til.indexOf

La propiedad lastIndex
Del mismo modo, el m√©todo no proporciona una manera c√≥moda de comenzar a buscar desde una posici√≥n determinada en la cadena. Pero proporciona una maneraconveniente.exec

Los objetos de expresi√≥n regular tienen propiedades. Una de estas propiedades es , que contiene la cadena desde la que se cre√≥ la expresi√≥n. Otra propiedad es , que controla, en algunas circunstancias limitadas, d√≥nde se iniciar√° la siguiente coincidencia.sourcelastIndex

Estas circunstancias son que la expresi√≥n regular debe tener habilitada la opci√≥n global () o pegajosa () y la coincidencia debe realizarse a trav√©s del m√©todo. Una vez m√°s, una soluci√≥n menos confusa habr√≠a sido simplemente permitir que se pasara un argumento adicional a , pero la confusi√≥n es una caracter√≠stica esencial de la interfaz de expresi√≥n regular de JavaScript.gyexecexec

let pattern = /y/g;
pattern.lastIndex = 3;
let match = pattern.exec("xyzzy");
console.log(match.index);
// ‚Üí 4
console.log(pattern.lastIndex);
// ‚Üí 5
Si la coincidencia se realiz√≥ correctamente, la llamada para actualizar autom√°ticamente la propiedad para que apunte despu√©s de la coincidencia. Si no se encontr√≥ ninguna coincidencia, se vuelve a establecer en cero, que tambi√©n es el valor que tiene en un objeto de expresi√≥n regular reci√©n construido.execlastIndexlastIndex

La diferencia entre las opciones globales y pegajosas es que, cuando se habilita sticky, la coincidencia s√≥lo tendr√° √©xito si comienza directamente en , mientras que con global, buscar√° por delante una posici√≥n donde una coincidencia puede comenzar.lastIndex

let global = /abc/g;
console.log(global.exec("xyz abc"));
// ‚Üí ["abc"]
let sticky = /abc/y;
console.log(sticky.exec("xyz abc"));
// ‚Üí null
Cuando se usa un valor de expresi√≥n regular compartida para varias llamadas, estas actualizaciones autom√°ticas de la propiedad pueden causar problemas. Es posible que la expresi√≥n regular se inicie accidentalmente en un √≠ndice que qued√≥ de una llamada anterior.execlastIndex

let digit = /\d/g;
console.log(digit.exec("here it is: 1"));
// ‚Üí ["1"]
console.log(digit.exec("and now: 1"));
// ‚Üí null
Otro efecto interesante de la opci√≥n global es que cambia la forma en que funciona el m√©todo en las cadenas. Cuando se llama con una expresi√≥n global, en lugar de devolver una matriz similar a la devuelta por , encontrar√° todas las coincidencias del patr√≥n en la cadena y devolver√° una matriz que contiene las cadenas coincidentes.matchexecmatch

console.log("Banana".match(/an/g));
// ‚Üí ["an", "an"]
So be cautious with global regular expressions. The cases where they are necessary‚Äîcalls to and places where you want to explicitly use ‚Äîare typically the only places where you want to use them.replacelastIndex

Looping over matches
A common thing to do is to scan through all occurrences of a pattern in a string, in a way that gives us access to the match object in the loop body. We can do this by using and .lastIndexexec

let input = "A string with 3 numbers in it... 42 and 88.";
let number = /\b\d+\b/g;
let match;
while (match = number.exec(input)) {
  console.log("Found", match[0], "at", match.index);
}
// ‚Üí Found 3 at 14
//   Found 42 at 33
//   Found 88 at 40
This makes use of the fact that the value of an assignment expression () is the assigned value. So by using as the condition in the statement, we perform the match at the start of each iteration, save its result in a binding, and stop looping when no more matches are found.=match = number.exec(input)while

Parsing an INI file
To conclude the chapter, we‚Äôll look at a problem that calls for regular expressions. Imagine we are writing a program to automatically collect information about our enemies from the Internet. (We will not actually write that program here, just the part that reads the configuration file. Sorry.) The configuration file looks like this:

searchengine=https://duckduckgo.com/?q=$1
spitefulness=9.7

; comments are preceded by a semicolon...
; each section concerns an individual enemy
[larry]
fullname=Larry Doe
type=kindergarten bully
website=http://www.geocities.com/CapeCanaveral/11451

[davaeorn]
fullname=Davaeorn
type=evil wizard
outputdir=/home/marijn/enemies/davaeorn
Las reglas exactas para este formato (que es un formato ampliamente utilizado, normalmente llamado un archivo INI) son las siguientes:

Las l√≠neas en blanco y las l√≠neas que comienzan con punto y coma se omiten.

L√≠neas envueltas e iniciar una nueva secci√≥n.[]

Las l√≠neas que contienen un identificador alfanum√©rico seguido de un car√°cter agregan una configuraci√≥n a la secci√≥n actual.=

Cualquier otra cosa no es v√°lida.

Nuestra tarea consiste en convertir una cadena como esta en un objeto cuyas propiedades contienen cadenas para la configuraci√≥n escritas antes del primer encabezado de secci√≥n y subobjetos para secciones, con esos subobjetos que contienen la configuraci√≥n de la secci√≥n.

Dado que el formato tiene que ser procesado l√≠nea por l√≠nea, dividir el archivo en l√≠neas separadas es un buen comienzo. Vimos el m√©todo en el cap√≠tulo 4. Algunos sistemas operativos, sin embargo, utilizan no s√≥lo un car√°cter de nueva l√≠nea para separar l√≠neas, sino un car√°cter de retorno de carro seguido de una nueva l√≠nea (). Dado que el m√©todo tambi√©n permite una expresi√≥n regular como argumento, podemos usar una expresi√≥n regular como dividir de una manera que permita ambas l√≠neas y entre.split"\r\n"split/\r?\n/"\n""\r\n"

function parseINI(string) {
  // Start with an object to hold the top-level fields
  let result = {};
  let section = result;
  string.split(/\r?\n/).forEach(line => {
    let match;
    if (match = line.match(/^(\w+)=(.*)$/)) {
      section[match[1]] = match[2];
    } else if (match = line.match(/^\[(.*)\]$/)) {
      section = result[match[1]] = {};
    } else if (!/^\s*(;.*)?$/.test(line)) {
      throw new Error("Line '" + line + "' is not valid.");
    }
  });
  return result;
}

console.log(parseINI(`
name=Vasilis
[address]
city=Tessaloniki`));
// ‚Üí {name: "Vasilis", address: {city: "Tessaloniki"}}
El c√≥digo pasa por encima de las l√≠neas del archivo y crea un objeto. Las propiedades de la parte superior se almacenan directamente en ese objeto, mientras que las propiedades que se encuentran en las secciones se almacenan en un objeto de secci√≥n independiente. El enlace apunta al objeto de la secci√≥n actual.section

Hay dos tipos de l√≠neas significativas: encabezados de secci√≥n o l√≠neas de propiedad. Cuando una l√≠nea es una propiedad normal, se almacena en la secci√≥n actual. Cuando se trata de un encabezado de secci√≥n, se crea un nuevo objeto de secci√≥n y se establece para apuntar a √©l.section

Tenga en cuenta el uso recurrente de y para asegurarse de que la expresi√≥n coincide con toda la l√≠nea, no s√≥lo una parte de ella. Dejar estos resultados en c√≥digo que en su mayor√≠a funciona pero se comporta de forma extra√±a para alguna entrada, que puede ser un error dif√≠cil de rastrear.^$

El patr√≥n es similar al truco de usar una asignaci√≥n como condici√≥n para . A menudo no est√° seguro de que la llamada a se realice correctamente, por lo que puede tener acceso al objeto resultante solo dentro de una instrucci√≥n que comprueba esto. Para no romper la agradable cadena de formularios, asignamos el resultado de la coincidencia a un enlace y usamos inmediatamente esa asignaci√≥n como prueba para la instrucci√≥n.if (match = string.match(...))whilematchifelse ifif

If a line is not a section header or a property, the function checks whether it is a comment or an empty line using the expression . Do you see how it works? The part between the parentheses will match comments, and the makes sure it also matches lines containing only whitespace. When a line doesn‚Äôt match any of the expected forms, the function throws an exception./^\s*(;.*)?$/?

International characters
Debido a la implementaci√≥n simplista inicial de JavaScript y al hecho de que este enfoque simplista se estableci√≥ m√°s tarde en piedra como comportamiento est√°ndar, las expresiones regulares de JavaScript son bastante tontas sobre los caracteres que no aparecen en el idioma ingl√©s. Por ejemplo, en lo que respecta a las expresiones regulares de JavaScript, un "car√°cter de palabra" es solo uno de los 26 caracteres del alfabeto latino (may√∫sculas o min√∫sculas), d√≠gitos decimales y, por alguna raz√≥n, el car√°cter de subrayado. Cosas como √© o Œ≤, que sin duda son caracteres de palabra, no coincidir√°n (y coincidir√°n con may√∫sculas, la categor√≠a nonword).\w\W

Por un extra√±o accidente hist√≥rico, (espacio en blanco) no tiene este problema y coincide con todos los caracteres que el est√°ndar Unicode considera espacios en blanco, incluyendo cosas como el espacio de no separaci√≥n y el separador de vocales mongoles.\s

Otro problema es que, de forma predeterminada, las expresiones regulares funcionan en unidades de c√≥digo, como se describe en el cap√≠tulo 5,no en caracteres reales. Esto significa que los caracteres que se componen de dos unidades de c√≥digo se comportan de forma extra√±a.

console.log(/üçé{3}/.test("üçéüçéüçé"));
// ‚Üí false
console.log(/<.>/.test("<üåπ>"));
// ‚Üí false
console.log(/<.>/u.test("<üåπ>"));
// ‚Üí true
El problema es que el üçé de la primera l√≠nea se trata como dos unidades de c√≥digo y la parte se aplica solo a la segunda. Del mismo modo, el punto coincide con una sola unidad de c√≥digo, no con los dos que componen el emoji de rosas.{3}

Debe agregar una opci√≥n (para Unicode) a la expresi√≥n regular para que trate estos caracteres correctamente. El comportamiento incorrecto sigue siendo el valor predeterminado, por desgracia, porque cambiar eso podr√≠a causar problemas para el c√≥digo existente que depende de √©l.u

Aunque esto s√≥lo estaba estandarizado y, en el momento de escribir, a√∫n no es ampliamente compatible, es posible utilizar en una expresi√≥n regular (que debe tener habilitada la opci√≥n Unicode) para que coincida con todos los caracteres a los que el est√°ndar Unicode asigna una propiedad determinada.\p

console.log(/\p{Script=Greek}/u.test("Œ±"));
// ‚Üí true
console.log(/\p{Script=Arabic}/u.test("Œ±"));
// ‚Üí false
console.log(/\p{Alphabetic}/u.test("Œ±"));
// ‚Üí true
console.log(/\p{Alphabetic}/u.test("!"));
// ‚Üí false
Unicode define una serie de propiedades √∫tiles, aunque encontrar la que necesita puede no ser siempre trivial. Puede usar la notaci√≥n para que coincida con cualquier car√°cter que tenga el valor especificado para esa propiedad. Si el nombre de propiedad se deja fuera, como en , se supone que el nombre es una propiedad binaria como o una categor√≠a como .\p{Property=Value}\p{Name}AlphabeticNumber

Resumen
Las expresiones regulares son objetos que representan patrones en cadenas. Usan su propio lenguaje para expresar estos patrones.

/abc/	Una secuencia de caracteres
/[abc]/	Cualquier car√°cter de un conjunto de caracteres
/[^abc]/	Cualquier car√°cter que no est√© en un conjunto de caracteres
/[0-9]/	Any character in a range of characters
/x+/	One or more occurrences of the pattern x
/x+?/	One or more occurrences, nongreedy
/x*/	Zero or more occurrences
/x?/	Zero or one occurrence
/x{2,4}/	Two to four occurrences
/(abc)/	A group
/a|b|c/	Any one of several patterns
/\d/	Any digit character
/\w/	Un car√°cter alfanum√©rico ("car√°cter de palabra")
/\s/	Cualquier car√°cter de espacio en blanco
/./	Cualquier personaje excepto las nuevas l√≠neas
/\b/	Un l√≠mite de palabra
/^/	Inicio de la entrada
/$/	Fin de la entrada
Una expresi√≥n regular tiene un m√©todo para probar si una cadena determinada coincide con ella. Tambi√©n tiene un m√©todo que, cuando se encuentra una coincidencia, devuelve una matriz que contiene todos los grupos coincidentes. Dicha matriz tiene una propiedad que indica d√≥nde comenz√≥ la coincidencia.testexecindex

Las cadenas tienen un m√©todo para que coincidan con una expresi√≥n regular y un m√©todo para buscar una, devolviendo solo la posici√≥n inicial de la coincidencia. Su m√©todo puede reemplazar las coincidencias de un patr√≥n con una cadena o funci√≥n de reemplazo.matchsearchreplace

Las expresiones regulares pueden tener opciones, que se escriben despu√©s de la barra diagonal de cierre. La opci√≥n hace que la coincidencia no distintive . La opci√≥n hace que la expresi√≥n sea global,lo que, entre otras cosas, hace que el m√©todo reemplace todas las instancias en lugar de solo la primera. La opci√≥n lo hace pegajoso, lo que significa que no buscar√° por delante y omitir√° parte de la cadena cuando busque una coincidencia. La opci√≥n activa el modo Unicode, que corrige una serie de problemas relacionados con el manejo de caracteres que ocupan dos unidades de c√≥digo.igreplaceyu

Las expresiones regulares son una herramienta afilada con un mango inc√≥modo. Simplifican algunas tareas enormemente, pero pueden volverse r√°pidamente inmanejables cuando se aplican a problemas complejos. Parte de saber c√≥mo usarlos es resistir el impulso de tratar de zapatear cosas que no pueden expresar limpiamente en ellos.

Ejercicios
Es casi inevitable que, en el curso de trabajar en estos ejercicios, te confundas y te frustres por el comportamiento inexplicable de alguna expresi√≥n regular. A veces ayuda introducir su expresi√≥n en una herramienta en l√≠nea como https://debuggex.com para ver si su visualizaci√≥n corresponde a lo que pretend√≠a y experimentar con la forma en que responde a varias cadenas de entrada.

Regexp golf
El golf de c√≥digo es un t√©rmino utilizado para el juego de tratar de expresar un programa en particular en el menor n√∫mero de personajes posible. Del mismo modo, el campo de golf regexp es la pr√°ctica de escribir una expresi√≥n regular tan peque√±a como sea posible para que coincida con un patr√≥n dado, y s√≥lo ese patr√≥n.

Para cada uno de los elementos siguientes, escriba una expresi√≥n regular para probar si alguna de las subcadenas dadas se produce en una cadena. La expresi√≥n regular debe coincidir √∫nicamente con las cadenas que contienen una de las subcadenas descritas. No se preocupe por los l√≠mites de palabras a menos que se mencione expl√≠citamente. Cuando la expresi√≥n funcione, vea si puede hacerla m√°s peque√±a.

coche y gato

pop y prop

hur√≥n, ferry,y ferrari

Cualquier palabra que termine en ious

Car√°cter de espacio en blanco seguido de un punto, coma, dos puntos o punto y coma

Una palabra de m√°s de seis letras

Una palabra sin la letra e (o E)

Consulte la tabla del resumen del cap√≠tulo para obtener ayuda. Pruebe cada soluci√≥n con unas pocas cadenas de prueba.

// Fill in the regular expressions

verify(/.../,
       ["my car", "bad cats"],
       ["camper", "high art"]);

verify(/.../,
       ["pop culture", "mad props"],
       ["plop", "prrrop"]);

verify(/.../,
       ["ferret", "ferry", "ferrari"],
       ["ferrum", "transfer A"]);

verify(/.../,
       ["how delicious", "spacious room"],
       ["ruinous", "consciousness"]);

verify(/.../,
       ["bad punctuation ."],
       ["escape the period"]);

verify(/.../,
       ["Siebentausenddreihundertzweiundzwanzig"],
       ["no", "three small words"]);

verify(/.../,
       ["red platypus", "wobbling nest"],
       ["earth bed", "learning ape", "BEET"]);


function verify(regexp, yes, no) {
  // Ignore unfinished exercises
  if (regexp.source == "...") return;
  for (let str of yes) if (!regexp.test(str)) {
    console.log(`Failure to match '${str}'`);
  }
  for (let str of no) if (regexp.test(str)) {
    console.log(`Unexpected match for '${str}'`);
  }
}
Estilo de cotizaci√≥n
Imagine que ha escrito una historia y ha utilizado comillas simples para marcar fragmentos de di√°logo. Ahora desea reemplazar todas las citas de di√°logo con comillas dobles, manteniendo las comillas simples utilizadas en contracciones como no lo son.

Piense en un patr√≥n que distinga estos dos tipos de uso de comillas y cree una llamada al m√©todo que realiza el reemplazo adecuado.replace

let text = "'I'm the cook,' he said, 'it's my job.'";
// Change this call.
console.log(text.replace(/A/g, "B"));
// ‚Üí "I'm the cook," he said, "it's my job."
N√∫meros de nuevo
Escriba una expresi√≥n que solo coincida con n√∫meros de estilo JavaScript. Debe admitir un signo menos o m√°s opcional delante del n√∫mero, el punto decimal y la notaci√≥n de exponente, o bien, de nuevo con un signo opcional delante del exponente. Tambi√©n tenga en cuenta que no es necesario que haya d√≠gitos delante o despu√©s del punto, pero el n√∫mero no puede ser un punto solo. Es decir, y son n√∫meros de JavaScript v√°lidos, pero un punto solitario no es.5e-31E10.55.

// Fill in this regular expression.
let number = /^...$/;

// Tests:
for (let str of ["1", "-1", "+15", "1.55", ".5", "5.",
                 "1.3e2", "1E-4", "1e+12"]) {
  if (!number.test(str)) {
    console.log(`Failed to match '${str}'`);
  }
}
for (let str of ["1a", "+-1", "1.2.3", "1+1", "1e4.5",
                 ".5.", "1f5", "."]) {
  if (number.test(str)) {
    console.log(`Incorrectly accepted '${str}'`);
  }
}
‚óÄ ‚óÜ ‚ñ∂
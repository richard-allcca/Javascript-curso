// =================================================================
//? 1. Logical Assignment Operators (&&= ||= ??=)
// =================================================================

// REVIEW - Los operadores l√≥gicos &&, || y ?? ahora tambi√©n pueden usarse para asignar valores de una forma m√°s sencilla y corta. Perfecto para asignar valores por defecto a variables.

// Si x es falsy, se le asigna y
x ||= y;
// Equivale a...
x || (x = y);

// Si x es truthy, se le asigna y
x &&= y;
// Equivale a...
x && (x = y);

// Si x es null o undefined, se le asigna y
x ??= y;
// Equivale a...
x ?? (x = y);

// NOTE - Hay que tener en cuenta que en estas asignaciones, adem√°s, entra el juego la evaluaci√≥n short-circuit. Esto quiere decir que estas asignaciones l√≥gicas se evaluan de izquierda a derecha. Si una expresi√≥n l√≥gica no se cumple, no se eval√∫a la siguiente.

//* Esto es importante para no cometer errores:

// este nuevo tipo de asignaci√≥n con &&
x &&= y;
// ‚úÖ es equivalente a...
x && (x = y);
// ‚ùå NO es equivalente a...
x = x && y;
// ya que la asignaci√≥n ocurre siempre independientemente de la evaluaci√≥n

// =================================================================
//? 2. Numeric Separator
// =================================================================

// REVIEW - Leer algunas cifras en JavaScript puede ser una tarea dif√≠cil. Para solucionar esto, el nuevo separador num√©rico _ te permite identificar de manera m√°s sencilla cualquier n√∫mero.

// Es dif√≠cil saber qu√© cifra representa
1000000000;
19436871.42;

//* ¬°Con Numeric Separator es m√°s f√°cil!
1_000_000_000; // Ah, es mil millones
100_000_000; // Y esto es cien millones
19_436_871.42; // ¬°De un vistazo!

// =================================================================
//? 3. Promise.any
// =================================================================

// REVIEW - ¬øAlguna vez has querido esperar una lista de promesas y que, al resolverse correctamente una cualquiera, continuar con la ejecuci√≥n de tu c√≥digo? Pues para eso se incorpora Promise.any().

const promises = [
   fetch("/from-external-api"),
   fetch("/from-memory"),
   fetch("/from-new-api"),
];

try {

   // espera a la primera respuesta correcta que termine
   const first = await Promise.any(promises);

   // La m√°s r√°pida fue la de memoria
   console.log(first); // respuesta desde 'from-memory'
} catch (error) {
   // ¬°Todas las promesas han fallado!
   console.assert(error instanceof AggregateError);
   // Log the rejection values:
   console.log(error.errors);
   // ‚Üí [
   //     <TypeError: Failed to fetch /from-external-api>,
   //     <TypeError: Failed to fetch /from-memory>,
   //     <TypeError: Failed to fetch /from-new-api>
   //   ]
}

// REVIEW - AggregateError

// Como has podido ver en el ejemplo anterior, ahora cuando la promesa falla, se devuelve una instancia de AggregateError. Este error es una instancia de Error y tiene una propiedad llamada errors que contiene una lista de errores para cada promesa que fall√≥.

//* La diferencia con Promise.race‚Ä¶

// Promise.race y Promise.any son muy similares. La diferencia es que Promise.race se resuelve cuando cualquier promesa ha sido resuelta o rechazada. En cambio Promise.any ignora las promesas que son rechazadas y s√≥lo se resuelve cuando se resuelve la primera‚Ä¶ o se rechaza cuando todas las promesas se han rechazado.

//* La tabla de diferencias de Promise

// Para que lo veas m√°s claro, he preparado una peque√±a tabla para diferenciar los diferentes m√©todos de Promise a la hora de trabajar con un array de promesas, para que eligas la que m√°s encaje con tu caso de uso.
/* 
+‚àí‚àí‚àí‚àí‚àí‚àí‚àí‚àí‚àí‚àí‚àí‚àí‚àí‚àí‚àí‚àí‚àí‚àí‚àí‚àí+‚àí‚àí‚àí‚àí‚àí‚àí‚àí‚àí‚àí‚àí‚àí‚àí‚àí‚àí‚àí‚àí‚àí‚àí‚àí‚àí‚àí‚àí‚àí‚àí‚àí‚àí‚àí‚àí‚àí‚àí‚àí‚àí‚àí‚àí‚àí‚àí‚àí‚àí‚àí‚àí‚àí‚àí‚àí‚àí‚àí‚àí‚àí‚àí-‚àí+‚àí‚àí‚àí‚àí‚àí‚àí‚àí‚àí‚àí‚àí‚àí‚àí‚àí‚àí‚àí-‚àí+
| M√©todo             | Descripci√≥n                                      | A√±adida en...   |
+‚àí‚àí‚àí‚àí‚àí‚àí‚àí‚àí‚àí‚àí‚àí‚àí‚àí‚àí‚àí‚àí‚àí‚àí‚àí‚àí+‚àí‚àí‚àí‚àí‚àí‚àí‚àí‚àí‚àí‚àí‚àí‚àí‚àí‚àí‚àí‚àí‚àí‚àí‚àí‚àí‚àí‚àí‚àí‚àí‚àí‚àí‚àí‚àí‚àí‚àí‚àí‚àí‚àí‚àí‚àí‚àí‚àí‚àí‚àí‚àí‚àí‚àí‚àí‚àí‚àí‚àí‚àí‚àí-‚àí+‚àí‚àí‚àí‚àí‚àí‚àí‚àí‚àí‚àí‚àí‚àí‚àí‚àí‚àí‚àí‚àí-+
| Promise.allSettled | Espera a todas las promesas se resuelvan o no    | ES2020          |
| Promise.all        | Se para cuando una promesa es rechazada          | ES2015          |
| Promise.race       | Se para cuando una promesa es rechaza o resuelta | ES2015          |
| Promise.any        | Se para cuando una promesa es resuelta           | ES2021          |
+‚àí‚àí‚àí‚àí‚àí‚àí‚àí‚àí‚àí‚àí‚àí‚àí‚àí‚àí‚àí‚àí‚àí‚àí‚àí‚àí+‚àí‚àí‚àí‚àí‚àí‚àí‚àí‚àí‚àí‚àí‚àí‚àí‚àí‚àí‚àí‚àí‚àí‚àí‚àí‚àí‚àí‚àí‚àí‚àí‚àí‚àí‚àí‚àí‚àí‚àí‚àí‚àí‚àí‚àí‚àí‚àí‚àí‚àí‚àí‚àí‚àí‚àí‚àí‚àí‚àí‚àí-‚àí‚àí‚àí+‚àí‚àí‚àí‚àí‚àí‚àí‚àí‚àí‚àí‚àí‚àí‚àí‚àí‚àí‚àí-‚àí+
 */

// =================================================================
//? 4. replaceAll
// =================================================================

// REVIEW - Hasta ahora, reemplazar todas las instancias de una cadena de texto en una cadena de texto te obligaba a usar Regex ya que replace, si le pasabas un string, lo que hac√≠a era s√≥lo reemplazar la primera instancia encontrada.

// ¬°Quiero cambiar las manzanas por bananas!
"üçèüçèüçãüçãüçäüçä".replace("üçè", "üçå");
// Pero qu√©...
// -> 'üçåüçèüçãüçãüçäüçä'

// ¬°Tienes que usar Regex para conseguirlo!
"üçèüçèüçãüçãüçäüçä".replace(/üçè/g, "üçå");

// ¬°Hasta ahora! ¬°Hola replaceAll!
"üçèüçèüçãüçãüçäüçä".replaceAll("üçè", "üçå");

// replaceAll queda mucho legible en nuestro c√≥digo y hace justo lo que esperaba: cambiar todas las instancias de una cadena de texto en una cadena de texto.

// =================================================================
//? 5. WeakRef
// =================================================================

// REVIEW - WeakRef te permite crear una referencia d√©bil a un objeto para no prevenir que se destruya por el Garbage Collector de JavaScript. ¬øPor qu√©? Pues por qu√© cuando creamos un objeto, especialmente si son grandes, estos no son autom√°ticamente destruidos por el Garbage Collector si existe una referencia a ellos.

// Con el m√©todo deref de WeakRef, podemos acceder a la referencia del objeto. Si la referencia al objeto ha sido eliminada, se devuelve undefined.

// Al crear un objeto...
let coords = { x: 13, y: 72 };
// Mientras tengas acceso a √©l directamente,
// el objeto no ser√° liberado de memoria
// por el Garbage Collector

// Ahora podemos creamos una referencia debil al objeto
const weakCoords = new WeakRef(coords);

// Recuperamos las propiedades del elemento
const ref = weakCoords.deref();
if (ref) {
   console.log("Todav√≠a tenemos acceso a las coordenadas");
   ref.x; // -> 13
} else {
   // ref es `undefined`
   console.log("La referencia ha sido eliminada");
}

// NOTE - Una cosa que debes tener en cuenta con WeakRef es que‚Ä¶ seguramente es mejor si no lo usas. Esta funcionalidad est√° pensado para casos muy espec√≠ficos que, en general, acabar√°n en librer√≠as y frameworks. Est√° bien que conozcas su existencia pero los casos de uso son muy limitados. La recolecci√≥n de basura en JavaScript puede variar mucho dependiendo del navegador, entorno y especificaciones del sistema.
